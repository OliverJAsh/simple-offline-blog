<!DOCTYPE html>
<html>
    <head>
        <title>Blog</title>
        <meta name="viewport" content="width=device-width">
    </head>
    <body>
        <h1><a href="/">Blog</a></h1>
        <div id="js-content">Loadingâ€¦</div>
        <script>
            /* eslint-env browser */
            window.addEventListener('DOMContentLoaded', function () {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(function () {
                        console.log('Service worker registered');
                    });

                var fragmentFromString = function (htmlString) {
                    return document.createRange().createContextualFragment(htmlString);
                };

                var getContentUrl = function (contentId) { return '/content/' + contentId; };

                var isContentCached = function (contentId) {
                    return caches.open('content').then(function (cache) {
                        return cache.match(getContentUrl(contentId)).then(function (response) {
                            return !! response;
                        });
                    });
                };

                var updateContent = function (fragment) {
                    var contentElement = document.querySelector('#js-content');
                    contentElement.innerHTML = '';
                    contentElement.appendChild(fragment);
                };

                var toArray = function (nodeList) {
                    return Array.prototype.slice.call(nodeList);
                };

                // Stale-while-revalidate

                // Load patterns:
                // cache - display - network - display - END
                // no cache - network - display - END

                // Tests:
                // - Server error
                // - No cache with network
                // - No cache without network
                // - Cache
                // - Cache then update

                var fetchFromNetwork = function (url) {
                    return fetch(url).then(function (response) {
                        return { type: 'network', response: response };
                    });
                };

                var fetchFromCacheOrElseNetwork = function (url) {
                    return caches.match(url)
                        .then(function (response) {
                            return response
                                ? { type: 'cache', response: response }
                                : fetchFromNetwork(url);
                        });
                };

                var responseToFragment = function (response) {
                    return response.clone().text().then(fragmentFromString);
                };

                var getResponses = function (url) {
                    // Cache or else network
                    var cacheOrElseNetworkPromise = fetchFromCacheOrElseNetwork(url);
                    // If first try was from cache, now try the network
                    var cacheThenNetworkPromise = cacheOrElseNetworkPromise.then(function (firstTry) {
                        if (firstTry.type === 'cache') {
                            return fetchFromNetwork(url);
                        }
                    });

                    return [
                        cacheOrElseNetworkPromise,
                        cacheThenNetworkPromise
                    ];
                };

                // Serve from cache or else network. When serving from cache,
                // fetch the newest content from the network to update the
                // content on screen and then revalidate the cache.
                // This function has side effects.
                var handlePageState = function (contentId, options) {
                    var url = getContentUrl(contentId);
                    var responses = getResponses(url);

                    var cacheOrElseNetworkPromise = responses[0];
                    var cacheThenNetworkPromise = responses[1];

                    return cacheOrElseNetworkPromise
                        .then(function (wrappedResponse) {
                            console.log('Render: from ' + wrappedResponse.type);
                            var fragment = responseToFragment(wrappedResponse.response);
                            return (wrappedResponse.response.ok ? fragment.then(options.transformerFn) : fragment)
                                .then(updateContent)
                                .then(function () {
                                    if (options.shouldCache && wrappedResponse.type === 'network') {
                                        console.log('Cache: first time');
                                        return caches.open('content').then(function (cache) {
                                            return cache.put(url, wrappedResponse.response);
                                        });
                                    }
                                });
                        }, function (error) {
                            return updateContent(fragmentFromString('<p>' + error.message + '</p>'));
                        })
                        .then(function () {
                            return cacheThenNetworkPromise.then(function (wrappedResponse) {
                                if (wrappedResponse && wrappedResponse.response.ok) {
                                    console.log('Render: from ' + wrappedResponse.type);
                                    return responseToFragment(wrappedResponse.response)
                                        .then(options.transformerFn)
                                        .then(updateContent)
                                        .then(function () {
                                            console.log('Cache: update');
                                            return caches.open('content').then(function (cache) {
                                                return cache.put(url, wrappedResponse.response);
                                            });
                                        });
                                }
                            });
                        });
                };

                //
                // Routing
                //

                var insertBefore = function (sourceNode, targetNode) {
                    sourceNode.parentNode.insertBefore(targetNode, sourceNode);
                };

                var homeRegExp = /^\/$/;
                var articleRegExp = /^\/articles\/(.*)$/;
                if (homeRegExp.test(location.pathname)) {
                    var contentId = 'articles';

                    var addOfflineNotes = function (fragment) {
                        // Warning: mutation
                        return Promise.all(toArray(fragment.querySelectorAll('li')).map(function (liElement) {
                            var thisContentId = new URL(liElement.querySelector('a').href).pathname.replace(/^\//, '');
                            return isContentCached(thisContentId).then(function (isCached) {
                                if (isCached) {
                                    var offlineNoteFragment = fragmentFromString('<p><strong>Available offline</strong></p>');
                                    insertBefore(liElement.querySelector('p'), offlineNoteFragment);
                                }
                            });
                        })).then(function () {
                            return fragment;
                        });
                    };

                    handlePageState(contentId, {
                        shouldCache: true,
                        transformerFn: addOfflineNotes
                    });
                }
                else if (articleRegExp.test(location.pathname)) {
                    var contentId = 'articles/' + location.pathname.match(articleRegExp)[1];

                    var prepend = function (sourceNode, targetNode) {
                        sourceNode.insertBefore(targetNode, sourceNode.firstChild);
                    };

                    var addOfflineCheckbox = function (fragment) {
                        // Warning: mutation
                        var cacheCheckboxFragment =
                            fragmentFromString('<label><input type="checkbox"> Read offline</label>');
                        prepend(fragment, cacheCheckboxFragment);

                        var cacheCheckboxElement = fragment.querySelector('input');
                        var url = getContentUrl(contentId);

                        return isContentCached(contentId)
                            .then(function (isCached) {
                                cacheCheckboxElement.checked = isCached;

                                cacheCheckboxElement.addEventListener('change', function (event) {
                                    return caches.open('content').then(function (cache) {
                                        var shouldCache = event.target.checked;
                                        if (shouldCache) {
                                            return cache.add(url).catch(function () {
                                                event.target.checked = false;
                                            });
                                        } else if (isCached) {
                                            cache.delete(url);
                                        }
                                    });
                                });
                            })
                            .then(function () { return fragment; });
                    };

                    handlePageState(contentId, { transformerFn: addOfflineCheckbox });
                }
            });

        </script>
    </body>
</html>
